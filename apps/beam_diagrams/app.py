import streamlit as st
import sympy
import random # Needed for roll_dice

# Import functions from the calculator and visualizer modules
from .beam_diagrams_calculator import calculate_beam_diagrams, interpret_dice_results, roll_dice
from .beam_diagrams_visualizer import plot_beam_schematic, plot_diagram

def main():
    st.title("📊 Generador Interactivo de Diagramas de Viga")
    st.markdown("""
    Esta aplicación simula la configuración de una viga basada en lanzamientos de dados (o entrada manual)
    y genera los diagramas de cortante y momento, junto con una memoria de cálculo interactiva.
    """)

    # --- Sidebar for Inputs ---
    st.sidebar.header("⚙️ Configuración de la Viga")
    input_method = st.sidebar.radio("Método de Entrada:", ("Lanzar Dados", "Entrada Manual"), key="beam_input_method")

    beam_params = {} # Initialize beam_params

    if input_method == "Lanzar Dados":
        st.sidebar.subheader("🎲 Lanzamiento de Dados")
        if st.sidebar.button("Lanzar Dados", key="roll_dice_button"):
            # Define how many dice for each parameter
            dice_rolls = {
                'support_left': roll_dice(3),
                'length': roll_dice(2),
                'point_load_p_pos': roll_dice(2),
                'point_load_p_mag': roll_dice(3),
                'dist_load_w_mag': roll_dice(3),
                'dist_load_w_span': roll_dice(2),
                'support_right': roll_dice(3),
                'EI': roll_dice(4) # EI is interpreted but not used in V, M calcs here
            }
            st.session_state.dice_rolls = dice_rolls # Store rolls
            # Interpret results immediately after rolling
            interpreted_params = interpret_dice_results(dice_rolls)
            st.session_state.beam_params = interpreted_params # Store interpreted params
            st.sidebar.write("Resultados Dados:", dice_rolls) # Display dice results

        # Display stored parameters if they exist and were generated by dice
        if 'beam_params' in st.session_state and 'dice_rolls' in st.session_state:
            beam_params = st.session_state.beam_params # Use the interpreted params
            st.sidebar.write("--- Parámetros Generados (Dados) ---")
            st.sidebar.json(beam_params) # Display generated params clearly
        elif 'beam_params' not in st.session_state:
             st.sidebar.info("Lanza los dados para generar la configuración.")


    elif input_method == "Entrada Manual":
        st.sidebar.subheader("✍️ Entrada Manual")
        # Use defaults from session state if available, otherwise use hardcoded defaults
        defaults = st.session_state.get('beam_params', {
            'length': 10.0, 'support_left': 'Simple', 'support_right': 'Simple',
            'point_load_p': {'magnitude': 5.0, 'position': 5.0},
            'dist_load_w': {'magnitude': 2.0, 'start': 2.0, 'end': 8.0},
            'EI': 20.0 # Default EI, though not used in V, M calcs
        })

        # Ensure nested dicts exist for defaults if loading from session state
        defaults.setdefault('point_load_p', {'magnitude': 0.0, 'position': 0.0})
        defaults.setdefault('dist_load_w', {'magnitude': 0.0, 'start': 0.0, 'end': 0.0})

        L = st.sidebar.number_input("Longitud (L)", min_value=0.1, value=float(defaults.get('length', 10.0)), step=0.5, key="manual_L_beam")
        support_left = st.sidebar.selectbox("Apoyo Izquierdo", ('Simple', 'Empotrado'), index=('Simple', 'Empotrado').index(defaults.get('support_left', 'Simple')), key="manual_support_left_beam")
        support_right = st.sidebar.selectbox("Apoyo Derecho", ('Libre', 'Simple', 'Empotrado'), index=('Libre', 'Simple', 'Empotrado').index(defaults.get('support_right', 'Simple')), key="manual_support_right_beam")

        st.sidebar.markdown("--- Carga Puntual (P) ---")
        # Allow negative magnitude
        p_mag = st.sidebar.number_input("Magnitud P (+: abajo, -: arriba)", value=float(defaults['point_load_p'].get('magnitude', 5.0)), step=0.5, key="manual_p_mag_beam", format="%.2f")
        # Ensure p_pos default is within the current length L
        default_p_pos = min(defaults['point_load_p'].get('position', L/2), L)
        p_pos = st.sidebar.number_input("Posición P", min_value=0.0, max_value=L, value=float(default_p_pos), step=0.1, key="manual_p_pos_beam")

        st.sidebar.markdown("--- Carga Distribuida (w) ---")
        # Allow negative magnitude
        w_mag = st.sidebar.number_input("Magnitud w (+: abajo, -: arriba)", value=float(defaults['dist_load_w'].get('magnitude', 2.0)), step=0.1, key="manual_w_mag_beam", format="%.2f")
        # Ensure w_start default is within the current length L
        default_w_start = min(defaults['dist_load_w'].get('start', L/4), L)
        w_start = st.sidebar.number_input("Inicio w", min_value=0.0, max_value=L, value=float(default_w_start), step=0.1, key="manual_w_start_beam")
        # Ensure w_end default is >= w_start and within L
        default_w_end = min(max(w_start, defaults['dist_load_w'].get('end', 3*L/4)), L)
        w_end = st.sidebar.number_input("Fin w", min_value=w_start, max_value=L, value=float(default_w_end), step=0.1, key="manual_w_end_beam")

        # EI input (though not used for V, M calculations here)
        # EI = st.sidebar.number_input("Módulo de Elasticidad (EI)", min_value=1.0, value=float(defaults.get('EI', 20.0)), step=1.0, key="manual_EI_beam")

        # Update beam_params dictionary for manual input
        beam_params = {
            'length': L,
            'support_left': support_left,
            'support_right': support_right,
            'point_load_p': {'magnitude': p_mag, 'position': p_pos},
            'dist_load_w': {'magnitude': w_mag, 'start': w_start, 'end': w_end},
            'EI': defaults.get('EI', 20.0) # Keep EI from defaults or previous state
        }
        # Store manual params in session state immediately so they persist
        st.session_state.beam_params = beam_params
        # Clear dice rolls if switching to manual input
        if 'dice_rolls' in st.session_state:
            del st.session_state.dice_rolls


    # --- Calculation and Display Area ---
    st.header("🔍 Análisis de la Viga")

    # Check if beam_params are available (either from dice or manual input)
    if 'beam_params' in st.session_state and st.session_state.beam_params:
        current_params = st.session_state.beam_params
        st.subheader("Parámetros Actuales")
        # Display parameters nicely
        st.markdown(f"""
        - **Longitud (L):** {current_params['length']}
        - **Apoyo Izquierdo:** {current_params['support_left']}
        - **Apoyo Derecho:** {current_params['support_right']}
        - **Carga Puntual P:** {current_params['point_load_p']['magnitude']} @ x={current_params['point_load_p']['position']:.2f}
        - **Carga Distribuida w:** {current_params['dist_load_w']['magnitude']} de x={current_params['dist_load_w']['start']:.2f} a x={current_params['dist_load_w']['end']:.2f}
        """)
        # st.json(current_params) # Alternative display

        try:
            # Calculate results
            results = calculate_beam_diagrams(current_params)

            # Display Beam Schematic
            st.subheader("📝 Diagrama Esquemático y Memoria de Cálculo")
            fig_beam = plot_beam_schematic(current_params, results)
            st.plotly_chart(fig_beam, use_container_width=True)

            # Display Calculation Steps in Expander
            st.write("**Pasos del Cálculo:**")
            with st.expander("Ver Pasos Detallados del Cálculo", expanded=False): # Start collapsed
                for step in results.get('calculation_steps', ["No hay pasos disponibles."]):
                    # Check for LaTeX patterns
                    if isinstance(step, str) and ('\\' in step or '{' in step or '}' in step or '^' in step or '_' in step) and not step.startswith("**"):
                        try:
                            st.latex(step) # Render as LaTeX
                        except Exception as latex_err:
                            st.warning(f"No se pudo renderizar como LaTeX: {step}")
                            st.text(step) # Fallback to text
                    elif isinstance(step, str) and step.startswith("`"): # Render reaction results in code blocks
                         st.code(step.strip("`"), language='text')
                    elif isinstance(step, str): # Render other steps as markdown
                         st.markdown(step, unsafe_allow_html=True)
                    else:
                         st.write(step) # Fallback for other types

            # Display Sign Conventions and Equations
            st.markdown("**Ecuaciones y Convenciones de Signos:**")
            
            # Sign Conventions
            with st.expander("Ver Convenciones de Signos", expanded=True):
                st.markdown("""
                **Convenciones de Signos:**
                1. **Cargas:**
                   - Cargas positivas (+) son hacia abajo
                   - Cargas negativas (-) son hacia arriba
                
                2. **Fuerza Cortante (V):**
                   - V positivo (+): hacia abajo en la cara izquierda, hacia arriba en la cara derecha
                   - Una reacción hacia arriba genera cortante negativo
                
                3. **Momento Flector (M):**
                   - M positivo (+): horario en la cara izquierda, antihorario en la cara derecha
                   - Relación: dM/dx = -V
                """)
            
            # Ecuaciones por Tramos (Student Format)
            with st.expander("Ver Ecuaciones por Tramos", expanded=True):
                st.markdown("Estas son las ecuaciones divididas por tramos:")
                if 'tramos_equations' in results:
                    for i, tramo in enumerate(results['tramos_equations'], 1):
                        st.markdown(f"**Tramo {i}** ({tramo['interval']})")
                        st.latex(tramo['V_eq'])
                        st.latex(tramo['M_eq'])
                else:
                    st.warning("No se pudieron generar las ecuaciones por tramos.")

            # Ecuaciones Generales (Mathematical Format)
            with st.expander("Ver Ecuaciones Generales", expanded=False):
                st.markdown("Estas son las ecuaciones generales usando funciones matemáticas:")
                if 'shear_eq' in results:
                    st.latex(f"V(x) = {sympy.latex(results['shear_eq'])}")
                if 'moment_eq' in results:
                    st.latex(f"M(x) = {sympy.latex(results['moment_eq'])}")

            # Display Diagrams
            st.subheader("📈 Diagramas Resultantes")
            col1, col2 = st.columns(2)
            with col1:
                if 'x_values' in results and 'shear_values' in results:
                    fig_shear = plot_diagram(results['x_values'], results['shear_values'], "Diagrama de Fuerza Cortante (V)", "Cortante (V)")
                    st.plotly_chart(fig_shear, use_container_width=True)
                else:
                    st.warning("No se pudieron generar los valores del diagrama de cortante.")
            with col2:
                 if 'x_values' in results and 'moment_values' in results:
                    fig_moment = plot_diagram(results['x_values'], results['moment_values'], "Diagrama de Momento Flector (M)", "Momento (M)")
                    st.plotly_chart(fig_moment, use_container_width=True)
                 else:
                    st.warning("No se pudieron generar los valores del diagrama de momento.")

        except Exception as e:
            st.error(f"Ocurrió un error durante el cálculo o la visualización: {e}")
            st.exception(e) # Show traceback for debugging

    else:
        st.info("Configure la viga usando el panel lateral para ver los resultados.")

# Note: No need for if __name__ == "__main__": here,
# as this will be imported and run by the page script.
